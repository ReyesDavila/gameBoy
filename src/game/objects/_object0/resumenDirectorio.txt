RESUMEN TÉCNICO DEL DIRECTORIO: ./_object0
Ámbito: Solo archivos contenidos en esta ubicación.
----------------------------------------------------------

ESTRUCTURA RELATIVA:
.
   _object0_settings.c
   resumenDirectorio.txt
   _object0_settings.h
   object0_init.c
   object0_draw.c
   object0_step.c
   resumenDirectorio.sh
----------------------------------------------------------
ARCHIVO: ./_object0_settings.c
----------------------------------------------------------
     1	#include "../../../engine/game_bridge.h"
     2	#include "_object0_settings.h"
     3	
     4	Object0 *obj0 = NULL;
     5	Object0 Object0_list[MAX_Object0];


----------------------------------------------------------
ARCHIVO: ./_object0_settings.h
----------------------------------------------------------
     1	#ifndef ENTITY_SETTINGS_H
     2	#define ENTITY_SETTINGS_H
     3	#include "../../engine/objects/entity_mgr.h"
     4	
     5	typedef struct {
     6	    Entity base;    // Obligatorio: siempre primero
     7	    int16_t x2, y2;   // Variable propia del objeto
     8	    int16_t vx, vy;
     9	    int16_t vx_max, vy_max;
    10	    int8_t dx, dy, ax, ay, fx, fy;
    11	} Object0;
    12	
    13	  
    14	extern Object0 *obj0; 
    15	#define MAX_Object0 10
    16	
    17	extern Object0 Object0_list[MAX_Object0];
    18	
    19	// Declaración de funciones (el motor las unirá mediante la Macro)
    20	void Object0_init(Object0 *self);
    21	void Object0_step(Object0 *self);
    22	void Object0_draw(Object0 *self);
    23	
    24	
    25	#endif

----------------------------------------------------------
ARCHIVO: ./object0_init.c
----------------------------------------------------------
     1	#include "../../../engine/game_bridge.h"
     2	
     3	void Object0_init(Object0 *self){
     4	    (void)self;
     5	
     6	        self->base.x = 80;
     7	        self->base.y = 72;
     8	        self->vx = 0;
     9	        self->vy = 0;
    10	        self->vx_max = 256;
    11	        self->vy_max = 256;
    12	        self->dx=0;
    13	        self->dy=0;
    14	        self->ax=6;
    15	        self->ay=6;
    16	        self->fx=2;
    17	        self->fy=2;
    18	}

----------------------------------------------------------
ARCHIVO: ./object0_draw.c
----------------------------------------------------------
     1	#include "../../../engine/game_bridge.h"
     2	
     3	void Object0_draw(Object0 *self){
     4	    (void)self;
     5	}

----------------------------------------------------------
ARCHIVO: ./object0_step.c
----------------------------------------------------------
     1	#include "../../../engine/game_bridge.h"
     2	
     3	void Object0_step(Object0 *self) {
     4	    (void)self;
     5	
     6	    // --- MOVIMIENTO X ---
     7	    int8_t jx = joystick_xpos();
     8	    if(jx) {
     9	        if (jx == -1) self->dx = -1; else self->dx = 1;
    10	        if (self->dx == 1) self->vx += self->ax; else self->vx -= self->ax;
    11	    } else {
    12	        if (self->vx > 0) self->vx -= self->fx;
    13	        else if (self->vx < 0) self->vx++;
    14	        if (abs(self->vx) < 5) self->vx = 0;
    15	    }
    16	    if (self->vx > self->vx_max) self->vx = self->vx_max;
    17	    else if (self->vx < -self->vx_max) self->vx = -self->vx_max;
    18	    self->x2 += self->vx;
    19	    self->base.x = (self->x2 >> 8);
    20	
    21	    // --- MOVIMIENTO Y ---
    22	    int8_t jy = joystick_ypos();
    23	    if(jy) {
    24	        if (jy == -1) self->dy = -1; else self->dy = 1;
    25	        if (self->dy == 1) self->vy += self->ay; else self->vy -= self->ay;
    26	    } else {
    27	        if (self->vy > 0) self->vy -= self->fy;
    28	        else if (self->vy < 0) self->vy++;
    29	        if (abs(self->vy) < 5) self->vy = 0;
    30	    }
    31	    if (self->vy > self->vy_max) self->vy = self->vy_max;
    32	    else if (self->vy < -self->vy_max) self->vy = -self->vy_max;
    33	    self->y2 += self->vy;
    34	    self->base.y = (self->y2 >> 8);
    35	
    36	
    37	    draw_tile(self->base.x, self->base.y, 2);
    38	
    39	    #ifdef MODO_DEBUG
    40	        debug_begin();
    41	        debug_watch(self->base.x);
    42	        debug_watch(self->base.y);
    43	    #endif
    44	
    45	}


----------------------------------------------------------
ARCHIVO: ./resumenDirectorio.sh
----------------------------------------------------------
     1	#!/bin/bash
     2	
     3	# [AI INSTRUCTION / PROTECTED CODE]
     4	# Este script es un ENCAPSULADOR DE CONTEXTO LOCAL ESTRICTO.
     5	# Prohibido mostrar rutas absolutas del sistema (/home/user/...).
     6	# Solo opera sobre el directorio relativo actual.
     7	
     8	OUTPUT_FILE="resumenDirectorio.txt"
     9	
    10	# Obtenemos solo el nombre de la carpeta actual (sin la ruta completa)
    11	NOMBRE_CARPETA_LOCAL=$(basename "$PWD")
    12	
    13	clear
    14	echo "=========================================================="
    15	echo "      ENCAPSULADOR: RESUMEN DE DIRECTORIO LOCAL          "
    16	echo "=========================================================="
    17	echo " Carpeta actual: ./$NOMBRE_CARPETA_LOCAL"
    18	
    19	# 1. PREPARACIÓN
    20	rm -f "$OUTPUT_FILE"
    21	echo "RESUMEN TÉCNICO DEL DIRECTORIO: ./$NOMBRE_CARPETA_LOCAL" > "$OUTPUT_FILE"
    22	echo "Ámbito: Solo archivos contenidos en esta ubicación." >> "$OUTPUT_FILE"
    23	echo "----------------------------------------------------------" >> "$OUTPUT_FILE"
    24	
    25	# 2. ÁRBOL LOCAL RELATIVO
    26	echo "[>] Generando mapa de archivos..."
    27	echo -e "\nESTRUCTURA RELATIVA:" >> "$OUTPUT_FILE"
    28	# Usamos find . para mantener rutas relativas ./ y evitar rutas absolutas
    29	find . -maxdepth 4 -not -path '*/.*' -not -path "./build/*" -not -path "./rom/*" | sed -e 's/[^-][^\/]*\// |/g' -e 's/|/  /g' >> "$OUTPUT_FILE"
    30	
    31	echo "=========================================================="
    32	echo "          PROCESANDO CONTENIDO RELATIVO                   "
    33	echo "=========================================================="
    34	
    35	total_archivos=0
    36	
    37	# 3. VOLCADO RECURSIVO (Solo extensiones permitidas)
    38	# Excluimos explícitamente el archivo de salida para evitar recursividad
    39	find . -type f \( -name "*.c" -o -name "*.h" -o -name "*.sh" -o -name "*.txt" -o -name "*.inc" -o -name "*.asm" \) \
    40	-not -path "./build/*" -not -path "./rom/*" -not -name "$OUTPUT_FILE" | while read -r archivo; do
    41	
    42	    # Informar al usuario (solo ruta relativa)
    43	    echo -n "[LECTURA]: $archivo ... "
    44	    
    45	    echo "----------------------------------------------------------" >> "$OUTPUT_FILE"
    46	    echo "ARCHIVO: $archivo" >> "$OUTPUT_FILE"
    47	    echo "----------------------------------------------------------" >> "$OUTPUT_FILE"
    48	    
    49	    # Volcar contenido
    50	    cat -n "$archivo" >> "$OUTPUT_FILE"
    51	    echo -e "\n" >> "$OUTPUT_FILE"
    52	    
    53	    ((total_archivos++))
    54	    echo -e "\033[0;32mOK\033[0m"
    55	
    56	done
    57	
    58	# 4. CIERRE
    59	echo "----------------------------------------------------------" >> "$OUTPUT_FILE"
    60	echo "FIN DEL RESUMEN" >> "$OUTPUT_FILE"
    61	
    62	echo ""
    63	echo "=========================================================="
    64	echo "          PROCESO FINALIZADO                             "
    65	echo "=========================================================="
    66	echo " [+] Archivos encapsulados: $total_archivos"
    67	echo " [+] Destino: ./$OUTPUT_FILE"
    68	echo "=========================================================="
    69	read -p "Presiona ENTER para finalizar..."


----------------------------------------------------------
FIN DEL RESUMEN
